{
  "language": "Solidity",
  "sources": {
    "contracts/Library.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\ncontract Library\n{\n\n    AggregatorV3Interface internal priceFeed;\n    /*\n    *@notice Instance of Library Item\n    */\n    struct content\n    {\n        uint256 ID;\n        string name;\n        string Link;\n        string description;\n        string category;\n        address seller;\n        uint256 price;\n\n    }\n\n    /*\n    *@notice Id counter \n    */\n    uint256 public privateCount = 0;\n    uint256 public publicCount = 0;\n\n\n    address private owner;\n\n    /*\n    *@notice maps user to their library\n    */\n    mapping(address=>mapping(uint256=>content)) userLib;\n    mapping(address=>content[]) privlib;\n    mapping(uint256 => content) public getContentById;\n\n    /**\n    @notice Events to log public library\n    */\n    event PublicUpload(string _name, string _Link, string _description, string _category, uint256 price);\n    event Share(address _sharer, string _filename, address _to);\n    event bought(address _seller, address _buyer, string _name, uint256 _price);\n\n\n    error incorrectPrice(uint256 price, uint256 paid);\n    error not_owner();\n    error incorrectId();\n\n    \n\n    /*\n    *@notice array of public library items\n    */\n    content[] public publicLib;\n\n    /**\n     * Network: Rinkeby\n     * Aggregator: ETH/USD\n     * Address: 0x8A753747A1Fa494EC906cE90E9f37563A8AF630e\n     */\n    constructor(address _owner)\n    {\n        owner= _owner;\n        priceFeed =  AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);\n    }\n\n    /*\n    *@notice uploads privately to users library\n    *@param _name file name\n    *@param _Link IPFS Link\n    *@param _description file description\n    *@param category file category\n    */\n    function PrivateUpload(string calldata _name, string calldata _link, string calldata _description, string calldata _category) external\n    {\n        privateCount++;\n        uint256 _privateCount = privateCount;\n        userLib[msg.sender][privateCount]=content(_privateCount, _name, _link, _description, _category, msg.sender, 0);\n        privlib[msg.sender].push(content(_privateCount, _name, _link, _description, _category, msg.sender, 0));\n    }\n\n    /**\n    @notice Uploads publicly into array publicLib\n    @param _name file name\n    @param _Link IPFS Link\n    @param _description file description\n    @param _category file category\n    */\n    function publicUpload(string calldata _name, string calldata _Link, string calldata _description, string calldata _category) external returns(string memory)\n    {\n        publicCount++;\n        uint256 pubCount = publicCount;\n        content memory Content = content(pubCount,_name, _Link, _description, _category, msg.sender,0);\n        publicLib.push(Content);\n        emit PublicUpload(_name, _Link, _description, _category, 0);\n         return (\"Added to Public Library\");\n    }\n\n\n    /**\n    @notice shares item in library\n    @param _to recieve addresses\n    @param _ID of file\n    */\n    function share(address[] calldata _to, uint256 _ID) external returns(string memory)\n    {\n        if(userLib[msg.sender][_ID].seller != address(0))\n        {\n         content memory c = userLib[msg.sender][_ID];\n        uint256 length= _to.length;\n        for(uint256 i=0; i< length; ) {\n        require(_to[i] != address(0),\"you cant share to zero address\");\n        \n        userLib[_to[i]][_ID] = content(c.ID, c.name, c.Link, c.description, c.category, c.seller,c.price);\n        privlib[_to[i]].push(content(c.ID,c.name, c.Link,c.description, c.category, c.seller,c.price));\n        emit Share(msg.sender, c.name, _to[i]);\n        unchecked {i++; }\n        }\n        return \"shared\";\n        }else\n        {\n            revert incorrectId();\n        }\n    }\n\n\n    /*\n    *@notice view Library items\n    */\n    function viewPrivateLib() public view returns(content[] memory )\n    {\n        return privlib[msg.sender];\n    }\n\n    /*\n    *@notice make private item public for sale\n    @param _ID id of item to make public\n    @param _price price of item\n    */\n    function publicSale(uint256 _ID, uint256 _price)external  //note this was our make public funtion\n    {\n        if(userLib[msg.sender][_ID].seller != address(0))\n        {\n        content memory c = userLib[msg.sender][_ID];\n        publicLib.push(content(c.ID, c.name, c.Link, c.description, c.category, msg.sender, _price));\n        emit PublicUpload(c.name, c.Link, c.description, c.category, _price);\n        }else\n        {\n            revert incorrectId();\n        }\n    }\n\n    /*\n    *@notice buy an item from the public marketplace \n    *@param arrayID the position of the item in the public items array\n    */\n    function buyItem(uint256 _arrayID) external payable\n    // guys we have to test this to ensure enough gas is calculated by metamask to also execute the transfer\n    {\n        content memory c= publicLib[_arrayID];\n        uint256 feed = (c.price * 10 ** 26) / getLatestPrice();\n        if(msg.value!=feed)\n        {\n            revert incorrectPrice({\n                price: feed,\n                paid: msg.value\n            });\n        }\n        userLib[msg.sender][c.ID]=content(c.ID,c.name,c.Link,c.description, c.category, c.seller,c.price);\n        privlib[msg.sender].push(content(c.ID,c.name,c.Link,c.description, c.category, c.seller,c.price));\n        emit bought(c.seller, msg.sender, c.name, c.price);\n        payable(c.seller).transfer((feed*95)/100);\n    }\n\n    /*\n    *@notice front end gets ether value of an item for sale\n    *@param arrayID the position of the item in the public items array\n    */\n    function assetPrice(uint256 _arrayID)external view returns(uint256)\n    {\n        content memory c= publicLib[_arrayID];\n        uint256 feed = ((c.price * 10 ** 26) / getLatestPrice());\n        return feed;\n    }\n\n     /*\n     *@notice Returns the latest price\n     */\n    function getLatestPrice() public view returns (uint) {\n        (\n            /*uint80 roundID*/,\n            int price,\n            /*uint startedAt*/,\n            /*uint timeStamp*/,\n            /*uint80 answeredInRound*/\n        ) = priceFeed.latestRoundData();\n        return uint(price);\n    }\n\n     /*\n     *@notice changes the owners address\n     *@param addr new owner address\n     */\n    function changeOwner(address _addr)external\n    {\n        if(msg.sender!= owner)\n        {\n            revert not_owner();\n        }\n        owner = _addr;\n    }\n\n     /**\n     *@notice Withdraws contract Revenue to owner\n     */\n    function withdraw()external\n    {\n        if(msg.sender != owner)\n        {\n            revert not_owner();\n        }\n        payable(msg.sender).transfer(address(this).balance);\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}